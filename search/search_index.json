{"config":{"indexing":"full","lang":["en","fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"index.html","text":"Bases de Donn\u00e9es NoSQL avec Neo4j \u00b6 Objectifs \u00b6 Installer Neo4j et cr\u00e9er une base de donn\u00e9es orient\u00e9e graphe Interroger une base de donn\u00e9es orient\u00e9e graphe avec Cypher Importer des donn\u00e9es dans Neo4j Cr\u00e9er une application autour de Neo4j avec Python Passer \u00e0 l'\u00e9chelle avec un cluster Neo4j Ressources \u00b6 Outils Docker Python Sources et r\u00e9f\u00e9rence Documentation Neo4j T\u00e9l\u00e9charger Neo4j Pr\u00e9sentation de Neo4j \u00b6 Neo4j est un Syst\u00e8me de Gestion de Bases de Donn\u00e9es orient\u00e9 graphe open source. Il manipule les donn\u00e9es sous leur nature connect\u00e9e en les repr\u00e9sentant sous la forme de graphe de fa\u00e7on native. Cette repr\u00e9sentation trouve ses sources dans la th\u00e9orie des graphes par Leonhard Euler et exploite naturellement ses algorithmes dans des applications comme : Syst\u00e8me de recommandation en temps r\u00e9el D\u00e9tection de fraude Transport et logistique D\u00e9tection de communaut\u00e9s Des exemples de cas d'utilisation sont publi\u00e9s sur Neo4j GraphGists \u00c9l\u00e9ments de Graphe \u00b6 Un graphe est compos\u00e9 de 2 \u00e9l\u00e9ments : Les noeuds (Vertices) : repr\u00e9sentant les entit\u00e9s du domaines. Ils poss\u00e8dent un ou plusieurs labels (\u00e9tiquettes) refl\u00e9tant leurs types et sous-types. Chaque noeud est d\u00e9crit par un ensemble de propri\u00e9t\u00e9s ou attributs. Les relations (Edges) : qui sont les arcs reliant les noeuds et repr\u00e9sentant une relation entre deux noeuds. Une relation poss\u00e8de un type et peut avoir aussi des propri\u00e9t\u00e9s . Par exemple, le grpahe ci-dessous repr\u00e9sente deux types de noeuds : Person et Movie (Personne et Film) et les relations entre eux : ACTED_IN, DIRECTED et REVIEWED (a_jou\u00e9_dans, a_r\u00e9alis\u00e9 et a_\u00e9valu\u00e9). Ce graphe comporte 1 neoud de type Movie et 4 noeuds de type Person. Deux personnes (\"Richard Harris\" et \"Gene Hackman\") ont jou\u00e9 dans le film \"Unforgiven\". \"Clint Eastwood\" \u00e0 jou\u00e9 dans ce film et l'a r\u00e9alis\u00e9. \"Jessica Thompson\" a donn\u00e9 un \u00e9valuation pour le film. Le film poss\u00e8de les propri\u00e9t\u00e9s released , tagline et title : La relation ACTED_IN poss\u00e8de la propri\u00e9t\u00e9 roles : Caract\u00e9ristiques \u00b6 Neo4j pr\u00e9sente les caract\u00e9ristiques et les fonctionnalit\u00e9s suivantes : Conformit\u00e9 aux propri\u00e9t\u00e9s ACID garantissant une int\u00e9grit\u00e9 des donn\u00e9es pour des applications OLTP/OLAP. Une mod\u00e9lisation en graphe de propri\u00e9t\u00e9s intuitive et flexible. Un langage (Cypher) simple et expressif. Support des langages Java, Python, .Net, Javascript et Go. Des outils : Data-importer pour ETL, Browser pour les requ\u00eates, Bloom pour la visualisation, le client Neo4j Desktop ... Des connecteurs pour l'int\u00e9gration avec Kafka, outils BI, ... Mise \u00e0 l'\u00e9chelle horizontale Optimisation des requ\u00eates (1000x plus rapide que les SGBDR sur les requ\u00eates complexes) Administration simplifi\u00e9e avec Neo4j OPS Manager Importation batch et incr\u00e9mentale Neo4j est le leader du classement des SGDB orient\u00e9s Graphe selon DB-Engines Neo4j figure parmi les 20 SGBD les plus utilis\u00e9s source","title":"Introduction"},{"location":"index.html#bases-de-donnees-nosql-avec-neo4j","text":"","title":"Bases de Donn\u00e9es NoSQL avec Neo4j"},{"location":"index.html#objectifs","text":"Installer Neo4j et cr\u00e9er une base de donn\u00e9es orient\u00e9e graphe Interroger une base de donn\u00e9es orient\u00e9e graphe avec Cypher Importer des donn\u00e9es dans Neo4j Cr\u00e9er une application autour de Neo4j avec Python Passer \u00e0 l'\u00e9chelle avec un cluster Neo4j","title":"Objectifs"},{"location":"index.html#ressources","text":"Outils Docker Python Sources et r\u00e9f\u00e9rence Documentation Neo4j T\u00e9l\u00e9charger Neo4j","title":"Ressources"},{"location":"index.html#presentation-de-neo4j","text":"Neo4j est un Syst\u00e8me de Gestion de Bases de Donn\u00e9es orient\u00e9 graphe open source. Il manipule les donn\u00e9es sous leur nature connect\u00e9e en les repr\u00e9sentant sous la forme de graphe de fa\u00e7on native. Cette repr\u00e9sentation trouve ses sources dans la th\u00e9orie des graphes par Leonhard Euler et exploite naturellement ses algorithmes dans des applications comme : Syst\u00e8me de recommandation en temps r\u00e9el D\u00e9tection de fraude Transport et logistique D\u00e9tection de communaut\u00e9s Des exemples de cas d'utilisation sont publi\u00e9s sur Neo4j GraphGists","title":"Pr\u00e9sentation de Neo4j"},{"location":"index.html#elements-de-graphe","text":"Un graphe est compos\u00e9 de 2 \u00e9l\u00e9ments : Les noeuds (Vertices) : repr\u00e9sentant les entit\u00e9s du domaines. Ils poss\u00e8dent un ou plusieurs labels (\u00e9tiquettes) refl\u00e9tant leurs types et sous-types. Chaque noeud est d\u00e9crit par un ensemble de propri\u00e9t\u00e9s ou attributs. Les relations (Edges) : qui sont les arcs reliant les noeuds et repr\u00e9sentant une relation entre deux noeuds. Une relation poss\u00e8de un type et peut avoir aussi des propri\u00e9t\u00e9s . Par exemple, le grpahe ci-dessous repr\u00e9sente deux types de noeuds : Person et Movie (Personne et Film) et les relations entre eux : ACTED_IN, DIRECTED et REVIEWED (a_jou\u00e9_dans, a_r\u00e9alis\u00e9 et a_\u00e9valu\u00e9). Ce graphe comporte 1 neoud de type Movie et 4 noeuds de type Person. Deux personnes (\"Richard Harris\" et \"Gene Hackman\") ont jou\u00e9 dans le film \"Unforgiven\". \"Clint Eastwood\" \u00e0 jou\u00e9 dans ce film et l'a r\u00e9alis\u00e9. \"Jessica Thompson\" a donn\u00e9 un \u00e9valuation pour le film. Le film poss\u00e8de les propri\u00e9t\u00e9s released , tagline et title : La relation ACTED_IN poss\u00e8de la propri\u00e9t\u00e9 roles :","title":"\u00c9l\u00e9ments de Graphe"},{"location":"index.html#caracteristiques","text":"Neo4j pr\u00e9sente les caract\u00e9ristiques et les fonctionnalit\u00e9s suivantes : Conformit\u00e9 aux propri\u00e9t\u00e9s ACID garantissant une int\u00e9grit\u00e9 des donn\u00e9es pour des applications OLTP/OLAP. Une mod\u00e9lisation en graphe de propri\u00e9t\u00e9s intuitive et flexible. Un langage (Cypher) simple et expressif. Support des langages Java, Python, .Net, Javascript et Go. Des outils : Data-importer pour ETL, Browser pour les requ\u00eates, Bloom pour la visualisation, le client Neo4j Desktop ... Des connecteurs pour l'int\u00e9gration avec Kafka, outils BI, ... Mise \u00e0 l'\u00e9chelle horizontale Optimisation des requ\u00eates (1000x plus rapide que les SGBDR sur les requ\u00eates complexes) Administration simplifi\u00e9e avec Neo4j OPS Manager Importation batch et incr\u00e9mentale Neo4j est le leader du classement des SGDB orient\u00e9s Graphe selon DB-Engines Neo4j figure parmi les 20 SGBD les plus utilis\u00e9s source","title":"Caract\u00e9ristiques"},{"location":"cluster.html","text":"Cluster Neo4j \u00b6 \u00b6","title":"Cluster Neo4j"},{"location":"cluster.html#cluster-neo4j","text":"","title":"Cluster Neo4j"},{"location":"cluster.html#_1","text":"","title":""},{"location":"cypher.html","text":"Premiers pas avec Cypher \u00b6 Base de donn\u00e9es exemple : Movie Graph \u00b6 Noeuds et relations \u00b6 C'est une BD graphe disponible avec Neo4j pour apprendre Cypher. Elle mod\u00e9lise les relations entre 2 noeuds : Person : repr\u00e9sentant une personne et peut \u00eatre un acteur, r\u00e9alisateur, produteur ou un spectateur Movie : un film Les relations possibles entre ces noeuds sont pr\u00e9sent\u00e9es dans le graphe ci-dessous. Ce graphe comporte 133 noeuds de type Person et 38 Movie. Propri\u00e9t\u00e9s \u00b6 Les noeuds Movie poss\u00e8de les propri\u00e9t\u00e9s : title : le titre du film qui est aussi son identifiant. tagline : r\u00e9sum\u00e9 du film. released : date de parution du film. Les noeuds Person poss\u00e8de les propri\u00e9t\u00e9s : name : le nom de la personne qui est aussi son identifiant. born : ann\u00e9e de naissabce. Les diff\u00e9rentes relations poss\u00e8dent aussi des propri\u00e9t\u00e9s : Relation Propri\u00e9t\u00e9s ACTED_IN propri\u00e9t\u00e9 roles (liste des r\u00f4les d'un acteur dans un film) DIRECTED ... PRODUCED ... WROTE ... REVIEWED propri\u00e9t\u00e9s rating (\u00e9valuation) et summary (un commentaire) Cr\u00e9er la base de donn\u00e9es \u00b6 D\u00e9marrer le guide de la base Movie Graph \u00e0 partir du shell Neo4j :guide movie-graph Cliquer sur Next puissur le bloc de code pour l'ins\u00e9rer dans le shell Le code est disponible dans le fichier movie-graph.cypher Ex\u00e9cuter le code V\u00e9rifier le graphe complet MATCH ( n ) RETURN n Pattern Cypher \u00b6 Le langage Cypher utilise des symboles sp\u00e9cifiques pour repr\u00e9senter les \u00e9l\u00e9ments du graphe dans ses requ\u00eates. Les neouds sont repr\u00e9sent\u00e9s par des parenth\u00e8ses () . Pour d\u00e9signer son type ou label on utilise : comme dans (:Person) . Les relation sont not\u00e9es avec deux tirets reliant deux noeuds, par exemple : (:Person)--(:Movie) . La direction de la relation est indiqu\u00e9e avec > ou < , comme (:Person)\u2192(:Movie) \u00e9quivalent \u00e0 (:Movie)\u2190(:Person) . Le type de la relation peut \u00eatre ajout\u00e9 entre les tirets entre crochets , par exemple [:ACTED_IN] . Les propri\u00e9t\u00e9s des noeuds et des relations sont ajout\u00e9s dans un bloc JSON. Des variables sont aussi ajout\u00e9es devant les labels comme (n:Person) . Pour des chemins de taille variable (n:Person)-[*]-(b:Person) . Pour des chemins de taille variable mais suivant un type de relation (n:Person)-[:ACTED*]-(b:Person) . Pour des chemins d'une taille sp\u00e9cifique (n:Person)-[*3..5]-(b:Person) (relation de niveau entre 3 et 5, la valeur 0 \u00e9quivaut une absence de relation). Exemple Cypher pattern ( m:Movie { title: 'Cloud Atlas' }) <- [ :ACTED_IN ] - ( p:Person ) Ce pattern repr\u00e9sente tous les noeuds de type Person qui ont jou\u00e9 (ACTED_IN) dans le film, \"Cloud Atlas\". Conventions Voici quelques conventions \u00e0 suivre avec Cypher : Un label commence par majuscule : Person Une relation est toute en majuscules : ACTED_IN Une propri\u00e9t\u00e9 est en minuscule : birthDate Lecture de donn\u00e9es \u00b6 L'\u00e9quivalent de SELECT dans Cypher est la commande MATCH . Syntaxe MATCH MATCH patter_cypher [ WHERE < condition > ] RETURN < expression1 > , ... [ SKIP < entier > ] [ LIMIT < entier > ] [ ORDER BY < champ > [ DESC ], ...] Sch\u00e9ma de la BD Visualiser le sch\u00e9ma de la base de donn\u00e9es en cours permet de comprendre la structure du graphe de propri\u00e9t\u00e9s \u00e0 manipuler avant de commencer \u00e0 \u00e9crire des requ\u00eates. Ce sch\u00e9am peut \u00eatre g\u00e9n\u00e9r\u00e9 automatiquement avec la commande : CALL db . schema . visualization Trouver tous les films MATCH ( n : Movie ) RETURN n Trouver la date de sortie du film \"The Matrix\" MATCH ( n : Movie { title : 'The Matrix' } ) RETURN n . released as ann\u00e9e ou MATCH ( n : Movie ) WHERE n . title = 'The Matrix' RETURN n . released as ann\u00e9e Trouver les films r\u00e9alis\u00e9s par \"Clint Eastwood\". MATCH ( m : Movie ) <- [: DIRECTED ] - (: Person { name : 'Clint Eastwood' } ) RETURN m Trouver 3 films sortis avant 1980 MATCH ( m : Movie ) WHERE m . released < 2000 RETURN m LIMIT 3 Trouver les acteurs dont le pr\u00e9nom est \"Michael\" MATCH ( p : Person ) - [: ACTED_IN ] -> () WHERE toLower ( p . name ) STARTS WITH 'michael' RETURN DISTINCT p . name Cypher multi-ligne Pour \u00e9crire du code Cypher sur plusieurs ligne, utiliser Shift + Enter pour retourner \u00e0 la ligne. Dans ce cas, pour ex\u00e9cuter le bloc appuyer sur Ctrl + Enter . Quels sont les r\u00e9alisateurs qui ont aussi jou\u00e9 un r\u00f4le dans le m\u00eame film qu'ils ont r\u00e9alis\u00e9. MATCH ( p : Person ) - [: ACTED_IN ] -> ( m : Movie ) WHERE exists ( ( p ) - [: DIRECTED ] -> ( m ) ) RETURN p , m Quels sont les commentaires laiss\u00e9s par les utilisateurs lors de l'\u00e9valuation du film \"The Da Vinci Code\". MATCH ( p : Person ) - [ r : REVIEWED ] -> ( m : Movie ) WHERE m . title = 'The Da Vinci Code' AND r . summary IS NOT NULL RETURN r . summary Trouver les personnes qui suivies par personnes qu'une personne suit (follows). MATCH ( p : Person ) - [: FOLLOWS * 2 ] -> ( q : Person ) WHERE p <> q RETURN p . name as Utilisateur , q . name as Second_niveau \u00c9criture de donn\u00e9es \u00b6 Insertion de noeuds \u00b6 Pour cr\u00e9er des \u00e9l\u00e9ments de grpahe deux clauses sont utilis\u00e9es par Cypher : CREATE et MERGE . La diff\u00e9rence entre ces clause est que MERGE requiert la saisie d'une valeur pour l'identifiant et \u00e9vite d'avoir des doublons. CREATE | MERGE < cypher_pattern > Cr\u00e9er un nouveau noeud Person MERGE (: Person { name : 'Tom Cruise' } ) Aucun noeud cr\u00e9\u00e9, parce qu'il est d\u00e9j\u00e0 existant. Cr\u00e9er une relation entre noeuds existants \"Angela Scope\" a \u00e9valu\u00e9 le film \"Cloud Atlas\" et a donn\u00e9 un rating=95 MATCH ( n : Person { name : 'Angela Scopee' } ) MATCH ( m : Movie { title : 'Cloud Atlas' } ) MERGE ( n ) - [: REVIEWED { rating : 95 } ] -> ( m ) Cr\u00e9er une structure Ajouter un film 'Jurassic Park' sorti en 1993 et son r\u00e9alisateur \"Steven Spielberg\". MERGE (: Movie { title : 'Jurassic Park' , released : 1993 } ) <- [: DIRECTED ] - (: Person { name : 'Steven Spielberg' } ) Mise \u00e0 jour de noeuds \u00b6 La clause MERGE sert aussi \u00e0 mettre \u00e0 jour les propri\u00e9t\u00e9s d'un noeud exitant. Il est possible de faire la mise \u00e0 jour en associant MATCH et SET . Cette derni\u00e8re permet de modifier la valeur d'un propri\u00e9t\u00e9 existante ou d\u00e9finir une nouvelle propri\u00e9t\u00e9. Pour supprimer une propri\u00e9t\u00e9 c'est REMOVE qui est utilis\u00e9e. Modifier l'\u00e9avluation de \"Angela Scope\" du film \"Cloud Atlas\" en 92 MATCH ( n : Person { name : 'Angela Scopee' } ) - [ r : REVIEWED { rating : 95 } ] -> ( m : Movie { title : 'Cloud Atlas' } ) SET r . rating = 92 RETURN n , m , r Supprimer la propri\u00e9t\u00e9 released du film 'Jurassic Park'. MATCH ( m : Movie ) WHERE m . title = 'Jurassic Park' REMOVE m . released Effectuer une mise \u00e0 jour selon le comportenent de MERGE // Trouver ou cr\u00e9er une personne MERGE ( p : Person { name : 'McKenna Grace' } ) // Ajouter cette propri\u00e9t\u00e9 ` createdAt ` si la personne est cr\u00e9\u00e9e ON CREATE SET p . createdAt = datetime () // Ajouter lanpropri\u00e9t\u00e9 ` updatedAt ` si la personne existe et n a pas \u00e9 t\u00e9 cr\u00e9\u00e9e ON MATCH SET p . updatedAt = datetime () // Dans tous les cas modifier la propri\u00e9t\u00e9 ` born ` SET p . born = 2006 RETURN p Ajouter un label \u00e0 noeud : ajouter le label Actor pour tous les Person qui ont au moins jou\u00e9 dans un film. MATCH ( p : Person ) WHERE exists (( p ) - [: DIRECTED ] - ()) SET p : Director Refactoring L'ajout de label est une technique utilis\u00e9e pour optimiser les requ\u00eates par \"Refactoring\" du graphe. C'est \u00e0 dire changement du mod\u00e8le de graphe. Dans l'exemple pr\u00e9c\u00e9dent, nous avons ajout\u00e9 un label pour toute personne qui a r\u00e9alis\u00e9 au moins un film. Nous pouvons donc utiliser ce nouveau label pour interroger directement le graphe avec le pattern (d:Director) . Neo4j recommande un nombre maximal de 4 labels par noeuds. Les figures suivantes permettent de comparer les plans d'ex\u00e9cution des 2 requ\u00eates : Supprimer tous les labels Director MATCH ( p : Director ) REMOVE p : Director Suppression \u00b6 C'est DELETE apr\u00e8s avoir obtenu une r\u00e9f\u00e9rence vers l'\u00e9l\u00e9ment \u00e0 supprimer (avec MATCH par exemple). Supprimer le review de \"Angela Scope\" du film \"Cloud Atlas\". MATCH ( n : Person { name : 'Angela Scopee' } ) - [ r : REVIEWED ] -> ( m : Movie { title : 'Cloud Atlas' } ) DELETE r Suppression d'un noeud et ses relations Quand un noeud poss\u00e8de des relation Neo4j emp\u00eache sa suppression. Pour supprimer automatiquement un noeud avec toutes ses relation, il faut utiliser DETACH DELETE Agr\u00e9gations \u00b6 Les agr\u00e9gations sont calcul\u00e9s dans la clause RETURN \u00e0 travers des fonctions comme : COUNT, SUM, AVG, MIN, MAX, ... Calculer le nombre de films dans le graphe MATCH ( p : Person ) RETURN count ( p ) AS Total Trouver le top 5 des acteurs et r\u00e9alisateurs ayant le plus de collaborations MATCH ( a : Person ) - [: ACTED_IN ] -> ( m : Movie ) <- [: DIRECTED ] - ( r : Person ) RETURN a . name as Acteur , r . name as R\u00e9alisateur , count ( * ) AS collaborations ORDER BY collaborations DESC LIMIT 5 Pour chaque film afficher les acteurs et leur nombre MATCH ( m : Movie ) <- [: ACTED_IN ] - ( a : Person ) RETURN m . title AS Film , collect ( a . name ) AS casting , count ( * ) AS nb_acteurs collect La fonction collect permet de cr\u00e9er une liste des valeurs pour des structures de type parent-enfants ou 1-n. Dans cet exemple, un film (titre) a plusieurs acteurs. Collect permet de grouper les acteurs dans une liste pour ne pas r\u00e9p\u00e9ter le film avec chaque acteur. C'est comme effectuer un GROUP BY sur le titre du film mais sans perdre le d\u00e9tail des enfants (acteurs). Quels sont les r\u00e9alisateurs de films sortis en 2008, 2009 et 2010 WITH [ 2008 , 2009 , 2010 ] AS ann\u00e9es UNWIND ann\u00e9es AS an MATCH ( r : Person ) - [: DIRECTED ] -> ( m : Movie { released : an } ) RETURN an , collect ( r . name ) as r\u00e9alisateurs Index et contraintes \u00b6 Les index permettent d'acc\u00e9l\u00e9rer les requ\u00eates et sont un outil indispensabe pour l'optimisation des requ\u00eates. Neo4j utilise 5 types d'index : RANGE LOOKUP TEXT FULLTEXT POINT CREATE [ RANGE | LOOKUP | TEXT | FULLTEXT | POINT ] INDEX < nom_index > FOR ( n : label ) ON ( l . prop1 , ...) Cr\u00e9er un index sur la date de sortie d'un film CREATE INDEX idx_film_released FOR ( m : Movie ) ON ( m . released ) Afficher les index SHOW INDEXES Ajouter une contrainte d'unicit\u00e9 d'une propri\u00e9t\u00e9 CREATE CONSTRAINT [ constraint_name ] [ IF NOT EXISTS ] FOR ( n : LabelName ) REQUIRE ( n . propertyName_1 , \u2026 , n . propertyName_n ) IS UNIQUE [ OPTIONS \"{\" option : value [, ...] \"}\" ] Autres types de contraintes D'autres contraintes sont disponibles mais uniquement dans la version Enterprise comme : Existence de propri\u00e9t\u00e9 de noeud Existence de propri\u00e9t\u00e9 de relation Contrainte Node Key R\u00e9f\u00e9rences du lanagage Cypher \u00b6 Types \u00b6 Dans Neo4j, les types suivants sont support\u00e9s : Number String Boolean The spatial type Point Date, Time, LocalTime, DateTime, LocalDateTime et Duration Lsit et Map Op\u00e9rateurs \u00b6 Aggregation operators DISTINCT Property operators . for static property access, [] for dynamic property access, = for replacing all properties, += for mutating specific properties Mathematical operators + , - , * , / , % , ^ Comparison operators = , <> , < , > , <= , >= , IS NULL , IS NOT NULL String-specific comparison operators STARTS WITH , ENDS WITH , CONTAINS , =~ for regex matching Boolean operators AND , OR , XOR , NOT String operators + for concatenation Temporal operators + and - for operations between durations and temporal instants/durations, * and / for operations between durations and numbers Map operators . for static value access by key, [] for dynamic value access by key List operators + for concatenation, IN to check existence of an element in a list, [] for accessing element(s) dynamically Fonctions \u00b6 Famille Exemples Pr\u00e9dicats all(), any(), exists(), isEmpty(), single() String left(), right(), substring(), trim(), toUpper(), toLower(), split(), replace(), ... List/Map keys(), labels(), nodes(), range(), relationships(), reverse(), size(), head(), last(), ... Maths abs(), ceil(), floor(), round(), rand(), isNaN(), ... Agr\u00e9gats min(), max(), sum(), count(), avg(), stdev(), ... Date/Time date(), datetime(), time(), datetime.fromepochmillis(), duration(), duration.between(), .... Manipulation de bases de donn\u00e9es \u00b6 Table 1. Database management command syntax Command Syntax Show Database SHOW { DATABASE name | DATABASES | DEFAULT DATABASE | HOME DATABASE } [WHERE expression] SHOW { DATABASE name | DATABASES | DEFAULT DATABASE | HOME DATABASE } YIELD { * | field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n] [WHERE expression] [RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]] Create Database CREATE DATABASE name [IF NOT EXISTS] [TOPOLOGY n PRIMAR{Y|IES} [m SECONDAR{Y|IES}]] [OPTIONS \"{\" option: value[, ...] \"}\"] [WAIT [n [SEC[OND[S]]]]|NOWAIT] CREATE OR REPLACE DATABASE name [TOPOLOGY n PRIMAR{Y|IES} [m SECONDAR{Y|IES}]] [OPTIONS \"{\" option: value[, ...] \"}\"] [WAIT [n [SEC[OND[S]]]]|NOWAIT] Create Composite Database CREATE COMPOSITE DATABASE name [IF NOT EXISTS] [WAIT [n [SEC[OND[S]]]]|NOWAIT] CREATE OR REPLACE COMPOSITE DATABASE name [WAIT [n [SEC[OND[S]]]]|NOWAIT] Alter Database ALTER DATABASE name [IF EXISTS] { SET ACCESS {READ ONLY | READ WRITE} | SET TOPOLOGY n PRIMAR{Y|IES} [m SECONDAR{Y|IES}] } Stop Database STOP DATABASE name [WAIT [n [SEC[OND[S]]]]|NOWAIT] Start Database START DATABASE name [WAIT [n [SEC[OND[S]]]]|NOWAIT] Drop Database DROP [COMPOSITE] DATABASE name [IF EXISTS] [{DUMP|DESTROY} [DATA]] [WAIT [n [SEC[OND[S]]]]|NOWAIT] Exercice \u00b6 Soit la base de donn\u00e9es Northwind dont le sch\u00e9ma est le suivant : Cr\u00e9er un nouveau container Neo4j pour l'exercice Imorter les donn\u00e9es en ex\u00e9cutant le code suivant : // tag :: constraints [] CREATE CONSTRAINT FOR ( o : Order ) REQUIRE o . orderID IS UNIQUE ; // end :: constraints [] // tag :: indexes [] CREATE INDEX FOR ( m : Product ) ON ( m . productID ); CREATE INDEX FOR ( m : Product ) ON ( m . productName ); CREATE INDEX FOR ( m : Category ) ON ( m . categoryID ); CREATE INDEX FOR ( m : Employee ) ON ( m . employeeID ); CREATE INDEX FOR ( m : Supplier ) ON ( m . supplierID ); CREATE INDEX FOR ( m : Customer ) ON ( m . customerID ); CREATE INDEX FOR ( m : Customer ) ON ( m . customerName ); // end :: indexes [] // tag :: nodes [] // Create customers LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/customers.csv\" AS row CREATE (: Customer { companyName : row . CompanyName , customerID : row . CustomerID , fax : row . Fax , phone : row . Phone } ); // Create products LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/products.csv\" AS row CREATE (: Product { productName : row . ProductName , productID : row . ProductID , unitPrice : toFloat ( row . UnitPrice ) } ); // Create suppliers LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/suppliers.csv\" AS row CREATE (: Supplier { companyName : row . CompanyName , supplierID : row . SupplierID } ); // Create employees LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/employees.csv\" AS row CREATE (: Employee { employeeID : row . EmployeeID , firstName : row . FirstName , lastName : row . LastName , title : row . Title } ); // Create categories LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/categories.csv\" AS row CREATE (: Category { categoryID : row . CategoryID , categoryName : row . CategoryName , description : row . Description } ); LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/orders.csv\" AS row MERGE ( order : Order { orderID : row . OrderID } ) ON CREATE SET order . shipName = row . ShipName ; // end :: nodes [] // tag :: rels_orders [] LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/orders.csv\" AS row MATCH ( order : Order { orderID : row . OrderID } ) MATCH ( product : Product { productID : row . ProductID } ) MERGE ( order ) - [ pu : PRODUCT ] -> ( product ) ON CREATE SET pu . unitPrice = toFloat ( row . UnitPrice ), pu . quantity = toFloat ( row . Quantity ); LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/orders.csv\" AS row MATCH ( order : Order { orderID : row . OrderID } ) MATCH ( employee : Employee { employeeID : row . EmployeeID } ) MERGE ( employee ) - [: SOLD ] -> ( order ); LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/orders.csv\" AS row MATCH ( order : Order { orderID : row . OrderID } ) MATCH ( customer : Customer { customerID : row . CustomerID } ) MERGE ( customer ) - [: PURCHASED ] -> ( order ); // end :: rels_orders [] // tag :: rels_products [] LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/products.csv\" AS row MATCH ( product : Product { productID : row . ProductID } ) MATCH ( supplier : Supplier { supplierID : row . SupplierID } ) MERGE ( supplier ) - [: SUPPLIES ] -> ( product ); LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/products.csv\" AS row MATCH ( product : Product { productID : row . ProductID } ) MATCH ( category : Category { categoryID : row . CategoryID } ) MERGE ( product ) - [: PART_OF ] -> ( category ); // end :: rels_products [] // tag :: rels_employees [] LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/employees.csv\" AS row MATCH ( employee : Employee { employeeID : row . EmployeeID } ) MATCH ( manager : Employee { employeeID : row . ReportsTo } ) MERGE ( employee ) - [: REPORTS_TO ] -> ( manager ); // end :: rels_employees [] R\u00e9pondre aux requ\u00eates suivantes : Trouver les produits et leurs prix. Trouver les informations sur les produits 'Chocolade' & 'Pavlova'. Trouver les informations sur les produits dont le nom commence par \"C\u201d et le prix >50. Requ\u00eate pr\u00e9c\u00e9dente en consid\u00e9rant \"sales price\" au lieu du prix du produit. Montant Total des achats par client et produit. Top 10 des employ\u00e9s selon les commandes vendues. Un employ\u00e9 est rattach\u00e9 \u00e0 combien de personnes de fa\u00e7on directe ou indirecte. \u00c0 qui les personnes nomm\u00e9es \u201cRobert\u201d sont-ils rattach\u00e9es. Qui n'a pas de personne \u00e0 qui il rattach\u00e9e ? Trouver les fournisseurs (Suppliers), le nombre de cat\u00e9gories qu'ils fournissent et la liste de ces cat\u00e9gories. Le client qui a achet\u00e9 le plus grand montant de la cat\u00e9gorie \"beverages\". Les 5 produits les plus populaires selon le nombre de commandes.","title":"Cypher"},{"location":"cypher.html#premiers-pas-avec-cypher","text":"","title":"Premiers pas avec Cypher"},{"location":"cypher.html#base-de-donnees-exemple-movie-graph","text":"","title":"Base de donn\u00e9es exemple : Movie Graph"},{"location":"cypher.html#noeuds-et-relations","text":"C'est une BD graphe disponible avec Neo4j pour apprendre Cypher. Elle mod\u00e9lise les relations entre 2 noeuds : Person : repr\u00e9sentant une personne et peut \u00eatre un acteur, r\u00e9alisateur, produteur ou un spectateur Movie : un film Les relations possibles entre ces noeuds sont pr\u00e9sent\u00e9es dans le graphe ci-dessous. Ce graphe comporte 133 noeuds de type Person et 38 Movie.","title":"Noeuds et relations"},{"location":"cypher.html#proprietes","text":"Les noeuds Movie poss\u00e8de les propri\u00e9t\u00e9s : title : le titre du film qui est aussi son identifiant. tagline : r\u00e9sum\u00e9 du film. released : date de parution du film. Les noeuds Person poss\u00e8de les propri\u00e9t\u00e9s : name : le nom de la personne qui est aussi son identifiant. born : ann\u00e9e de naissabce. Les diff\u00e9rentes relations poss\u00e8dent aussi des propri\u00e9t\u00e9s : Relation Propri\u00e9t\u00e9s ACTED_IN propri\u00e9t\u00e9 roles (liste des r\u00f4les d'un acteur dans un film) DIRECTED ... PRODUCED ... WROTE ... REVIEWED propri\u00e9t\u00e9s rating (\u00e9valuation) et summary (un commentaire)","title":"Propri\u00e9t\u00e9s"},{"location":"cypher.html#creer-la-base-de-donnees","text":"D\u00e9marrer le guide de la base Movie Graph \u00e0 partir du shell Neo4j :guide movie-graph Cliquer sur Next puissur le bloc de code pour l'ins\u00e9rer dans le shell Le code est disponible dans le fichier movie-graph.cypher Ex\u00e9cuter le code V\u00e9rifier le graphe complet MATCH ( n ) RETURN n","title":"Cr\u00e9er la base de donn\u00e9es"},{"location":"cypher.html#pattern-cypher","text":"Le langage Cypher utilise des symboles sp\u00e9cifiques pour repr\u00e9senter les \u00e9l\u00e9ments du graphe dans ses requ\u00eates. Les neouds sont repr\u00e9sent\u00e9s par des parenth\u00e8ses () . Pour d\u00e9signer son type ou label on utilise : comme dans (:Person) . Les relation sont not\u00e9es avec deux tirets reliant deux noeuds, par exemple : (:Person)--(:Movie) . La direction de la relation est indiqu\u00e9e avec > ou < , comme (:Person)\u2192(:Movie) \u00e9quivalent \u00e0 (:Movie)\u2190(:Person) . Le type de la relation peut \u00eatre ajout\u00e9 entre les tirets entre crochets , par exemple [:ACTED_IN] . Les propri\u00e9t\u00e9s des noeuds et des relations sont ajout\u00e9s dans un bloc JSON. Des variables sont aussi ajout\u00e9es devant les labels comme (n:Person) . Pour des chemins de taille variable (n:Person)-[*]-(b:Person) . Pour des chemins de taille variable mais suivant un type de relation (n:Person)-[:ACTED*]-(b:Person) . Pour des chemins d'une taille sp\u00e9cifique (n:Person)-[*3..5]-(b:Person) (relation de niveau entre 3 et 5, la valeur 0 \u00e9quivaut une absence de relation). Exemple Cypher pattern ( m:Movie { title: 'Cloud Atlas' }) <- [ :ACTED_IN ] - ( p:Person ) Ce pattern repr\u00e9sente tous les noeuds de type Person qui ont jou\u00e9 (ACTED_IN) dans le film, \"Cloud Atlas\". Conventions Voici quelques conventions \u00e0 suivre avec Cypher : Un label commence par majuscule : Person Une relation est toute en majuscules : ACTED_IN Une propri\u00e9t\u00e9 est en minuscule : birthDate","title":"Pattern Cypher"},{"location":"cypher.html#lecture-de-donnees","text":"L'\u00e9quivalent de SELECT dans Cypher est la commande MATCH . Syntaxe MATCH MATCH patter_cypher [ WHERE < condition > ] RETURN < expression1 > , ... [ SKIP < entier > ] [ LIMIT < entier > ] [ ORDER BY < champ > [ DESC ], ...] Sch\u00e9ma de la BD Visualiser le sch\u00e9ma de la base de donn\u00e9es en cours permet de comprendre la structure du graphe de propri\u00e9t\u00e9s \u00e0 manipuler avant de commencer \u00e0 \u00e9crire des requ\u00eates. Ce sch\u00e9am peut \u00eatre g\u00e9n\u00e9r\u00e9 automatiquement avec la commande : CALL db . schema . visualization Trouver tous les films MATCH ( n : Movie ) RETURN n Trouver la date de sortie du film \"The Matrix\" MATCH ( n : Movie { title : 'The Matrix' } ) RETURN n . released as ann\u00e9e ou MATCH ( n : Movie ) WHERE n . title = 'The Matrix' RETURN n . released as ann\u00e9e Trouver les films r\u00e9alis\u00e9s par \"Clint Eastwood\". MATCH ( m : Movie ) <- [: DIRECTED ] - (: Person { name : 'Clint Eastwood' } ) RETURN m Trouver 3 films sortis avant 1980 MATCH ( m : Movie ) WHERE m . released < 2000 RETURN m LIMIT 3 Trouver les acteurs dont le pr\u00e9nom est \"Michael\" MATCH ( p : Person ) - [: ACTED_IN ] -> () WHERE toLower ( p . name ) STARTS WITH 'michael' RETURN DISTINCT p . name Cypher multi-ligne Pour \u00e9crire du code Cypher sur plusieurs ligne, utiliser Shift + Enter pour retourner \u00e0 la ligne. Dans ce cas, pour ex\u00e9cuter le bloc appuyer sur Ctrl + Enter . Quels sont les r\u00e9alisateurs qui ont aussi jou\u00e9 un r\u00f4le dans le m\u00eame film qu'ils ont r\u00e9alis\u00e9. MATCH ( p : Person ) - [: ACTED_IN ] -> ( m : Movie ) WHERE exists ( ( p ) - [: DIRECTED ] -> ( m ) ) RETURN p , m Quels sont les commentaires laiss\u00e9s par les utilisateurs lors de l'\u00e9valuation du film \"The Da Vinci Code\". MATCH ( p : Person ) - [ r : REVIEWED ] -> ( m : Movie ) WHERE m . title = 'The Da Vinci Code' AND r . summary IS NOT NULL RETURN r . summary Trouver les personnes qui suivies par personnes qu'une personne suit (follows). MATCH ( p : Person ) - [: FOLLOWS * 2 ] -> ( q : Person ) WHERE p <> q RETURN p . name as Utilisateur , q . name as Second_niveau","title":"Lecture de donn\u00e9es"},{"location":"cypher.html#ecriture-de-donnees","text":"","title":"\u00c9criture de donn\u00e9es"},{"location":"cypher.html#insertion-de-noeuds","text":"Pour cr\u00e9er des \u00e9l\u00e9ments de grpahe deux clauses sont utilis\u00e9es par Cypher : CREATE et MERGE . La diff\u00e9rence entre ces clause est que MERGE requiert la saisie d'une valeur pour l'identifiant et \u00e9vite d'avoir des doublons. CREATE | MERGE < cypher_pattern > Cr\u00e9er un nouveau noeud Person MERGE (: Person { name : 'Tom Cruise' } ) Aucun noeud cr\u00e9\u00e9, parce qu'il est d\u00e9j\u00e0 existant. Cr\u00e9er une relation entre noeuds existants \"Angela Scope\" a \u00e9valu\u00e9 le film \"Cloud Atlas\" et a donn\u00e9 un rating=95 MATCH ( n : Person { name : 'Angela Scopee' } ) MATCH ( m : Movie { title : 'Cloud Atlas' } ) MERGE ( n ) - [: REVIEWED { rating : 95 } ] -> ( m ) Cr\u00e9er une structure Ajouter un film 'Jurassic Park' sorti en 1993 et son r\u00e9alisateur \"Steven Spielberg\". MERGE (: Movie { title : 'Jurassic Park' , released : 1993 } ) <- [: DIRECTED ] - (: Person { name : 'Steven Spielberg' } )","title":"Insertion de noeuds"},{"location":"cypher.html#mise-a-jour-de-noeuds","text":"La clause MERGE sert aussi \u00e0 mettre \u00e0 jour les propri\u00e9t\u00e9s d'un noeud exitant. Il est possible de faire la mise \u00e0 jour en associant MATCH et SET . Cette derni\u00e8re permet de modifier la valeur d'un propri\u00e9t\u00e9 existante ou d\u00e9finir une nouvelle propri\u00e9t\u00e9. Pour supprimer une propri\u00e9t\u00e9 c'est REMOVE qui est utilis\u00e9e. Modifier l'\u00e9avluation de \"Angela Scope\" du film \"Cloud Atlas\" en 92 MATCH ( n : Person { name : 'Angela Scopee' } ) - [ r : REVIEWED { rating : 95 } ] -> ( m : Movie { title : 'Cloud Atlas' } ) SET r . rating = 92 RETURN n , m , r Supprimer la propri\u00e9t\u00e9 released du film 'Jurassic Park'. MATCH ( m : Movie ) WHERE m . title = 'Jurassic Park' REMOVE m . released Effectuer une mise \u00e0 jour selon le comportenent de MERGE // Trouver ou cr\u00e9er une personne MERGE ( p : Person { name : 'McKenna Grace' } ) // Ajouter cette propri\u00e9t\u00e9 ` createdAt ` si la personne est cr\u00e9\u00e9e ON CREATE SET p . createdAt = datetime () // Ajouter lanpropri\u00e9t\u00e9 ` updatedAt ` si la personne existe et n a pas \u00e9 t\u00e9 cr\u00e9\u00e9e ON MATCH SET p . updatedAt = datetime () // Dans tous les cas modifier la propri\u00e9t\u00e9 ` born ` SET p . born = 2006 RETURN p Ajouter un label \u00e0 noeud : ajouter le label Actor pour tous les Person qui ont au moins jou\u00e9 dans un film. MATCH ( p : Person ) WHERE exists (( p ) - [: DIRECTED ] - ()) SET p : Director Refactoring L'ajout de label est une technique utilis\u00e9e pour optimiser les requ\u00eates par \"Refactoring\" du graphe. C'est \u00e0 dire changement du mod\u00e8le de graphe. Dans l'exemple pr\u00e9c\u00e9dent, nous avons ajout\u00e9 un label pour toute personne qui a r\u00e9alis\u00e9 au moins un film. Nous pouvons donc utiliser ce nouveau label pour interroger directement le graphe avec le pattern (d:Director) . Neo4j recommande un nombre maximal de 4 labels par noeuds. Les figures suivantes permettent de comparer les plans d'ex\u00e9cution des 2 requ\u00eates : Supprimer tous les labels Director MATCH ( p : Director ) REMOVE p : Director","title":"Mise \u00e0 jour de noeuds"},{"location":"cypher.html#suppression","text":"C'est DELETE apr\u00e8s avoir obtenu une r\u00e9f\u00e9rence vers l'\u00e9l\u00e9ment \u00e0 supprimer (avec MATCH par exemple). Supprimer le review de \"Angela Scope\" du film \"Cloud Atlas\". MATCH ( n : Person { name : 'Angela Scopee' } ) - [ r : REVIEWED ] -> ( m : Movie { title : 'Cloud Atlas' } ) DELETE r Suppression d'un noeud et ses relations Quand un noeud poss\u00e8de des relation Neo4j emp\u00eache sa suppression. Pour supprimer automatiquement un noeud avec toutes ses relation, il faut utiliser DETACH DELETE","title":"Suppression"},{"location":"cypher.html#agregations","text":"Les agr\u00e9gations sont calcul\u00e9s dans la clause RETURN \u00e0 travers des fonctions comme : COUNT, SUM, AVG, MIN, MAX, ... Calculer le nombre de films dans le graphe MATCH ( p : Person ) RETURN count ( p ) AS Total Trouver le top 5 des acteurs et r\u00e9alisateurs ayant le plus de collaborations MATCH ( a : Person ) - [: ACTED_IN ] -> ( m : Movie ) <- [: DIRECTED ] - ( r : Person ) RETURN a . name as Acteur , r . name as R\u00e9alisateur , count ( * ) AS collaborations ORDER BY collaborations DESC LIMIT 5 Pour chaque film afficher les acteurs et leur nombre MATCH ( m : Movie ) <- [: ACTED_IN ] - ( a : Person ) RETURN m . title AS Film , collect ( a . name ) AS casting , count ( * ) AS nb_acteurs collect La fonction collect permet de cr\u00e9er une liste des valeurs pour des structures de type parent-enfants ou 1-n. Dans cet exemple, un film (titre) a plusieurs acteurs. Collect permet de grouper les acteurs dans une liste pour ne pas r\u00e9p\u00e9ter le film avec chaque acteur. C'est comme effectuer un GROUP BY sur le titre du film mais sans perdre le d\u00e9tail des enfants (acteurs). Quels sont les r\u00e9alisateurs de films sortis en 2008, 2009 et 2010 WITH [ 2008 , 2009 , 2010 ] AS ann\u00e9es UNWIND ann\u00e9es AS an MATCH ( r : Person ) - [: DIRECTED ] -> ( m : Movie { released : an } ) RETURN an , collect ( r . name ) as r\u00e9alisateurs","title":"Agr\u00e9gations"},{"location":"cypher.html#index-et-contraintes","text":"Les index permettent d'acc\u00e9l\u00e9rer les requ\u00eates et sont un outil indispensabe pour l'optimisation des requ\u00eates. Neo4j utilise 5 types d'index : RANGE LOOKUP TEXT FULLTEXT POINT CREATE [ RANGE | LOOKUP | TEXT | FULLTEXT | POINT ] INDEX < nom_index > FOR ( n : label ) ON ( l . prop1 , ...) Cr\u00e9er un index sur la date de sortie d'un film CREATE INDEX idx_film_released FOR ( m : Movie ) ON ( m . released ) Afficher les index SHOW INDEXES Ajouter une contrainte d'unicit\u00e9 d'une propri\u00e9t\u00e9 CREATE CONSTRAINT [ constraint_name ] [ IF NOT EXISTS ] FOR ( n : LabelName ) REQUIRE ( n . propertyName_1 , \u2026 , n . propertyName_n ) IS UNIQUE [ OPTIONS \"{\" option : value [, ...] \"}\" ] Autres types de contraintes D'autres contraintes sont disponibles mais uniquement dans la version Enterprise comme : Existence de propri\u00e9t\u00e9 de noeud Existence de propri\u00e9t\u00e9 de relation Contrainte Node Key","title":"Index et contraintes"},{"location":"cypher.html#references-du-lanagage-cypher","text":"","title":"R\u00e9f\u00e9rences du lanagage Cypher"},{"location":"cypher.html#types","text":"Dans Neo4j, les types suivants sont support\u00e9s : Number String Boolean The spatial type Point Date, Time, LocalTime, DateTime, LocalDateTime et Duration Lsit et Map","title":"Types"},{"location":"cypher.html#operateurs","text":"Aggregation operators DISTINCT Property operators . for static property access, [] for dynamic property access, = for replacing all properties, += for mutating specific properties Mathematical operators + , - , * , / , % , ^ Comparison operators = , <> , < , > , <= , >= , IS NULL , IS NOT NULL String-specific comparison operators STARTS WITH , ENDS WITH , CONTAINS , =~ for regex matching Boolean operators AND , OR , XOR , NOT String operators + for concatenation Temporal operators + and - for operations between durations and temporal instants/durations, * and / for operations between durations and numbers Map operators . for static value access by key, [] for dynamic value access by key List operators + for concatenation, IN to check existence of an element in a list, [] for accessing element(s) dynamically","title":"Op\u00e9rateurs"},{"location":"cypher.html#fonctions","text":"Famille Exemples Pr\u00e9dicats all(), any(), exists(), isEmpty(), single() String left(), right(), substring(), trim(), toUpper(), toLower(), split(), replace(), ... List/Map keys(), labels(), nodes(), range(), relationships(), reverse(), size(), head(), last(), ... Maths abs(), ceil(), floor(), round(), rand(), isNaN(), ... Agr\u00e9gats min(), max(), sum(), count(), avg(), stdev(), ... Date/Time date(), datetime(), time(), datetime.fromepochmillis(), duration(), duration.between(), ....","title":"Fonctions"},{"location":"cypher.html#manipulation-de-bases-de-donnees","text":"Table 1. Database management command syntax Command Syntax Show Database SHOW { DATABASE name | DATABASES | DEFAULT DATABASE | HOME DATABASE } [WHERE expression] SHOW { DATABASE name | DATABASES | DEFAULT DATABASE | HOME DATABASE } YIELD { * | field[, ...] } [ORDER BY field[, ...]] [SKIP n] [LIMIT n] [WHERE expression] [RETURN field[, ...] [ORDER BY field[, ...]] [SKIP n] [LIMIT n]] Create Database CREATE DATABASE name [IF NOT EXISTS] [TOPOLOGY n PRIMAR{Y|IES} [m SECONDAR{Y|IES}]] [OPTIONS \"{\" option: value[, ...] \"}\"] [WAIT [n [SEC[OND[S]]]]|NOWAIT] CREATE OR REPLACE DATABASE name [TOPOLOGY n PRIMAR{Y|IES} [m SECONDAR{Y|IES}]] [OPTIONS \"{\" option: value[, ...] \"}\"] [WAIT [n [SEC[OND[S]]]]|NOWAIT] Create Composite Database CREATE COMPOSITE DATABASE name [IF NOT EXISTS] [WAIT [n [SEC[OND[S]]]]|NOWAIT] CREATE OR REPLACE COMPOSITE DATABASE name [WAIT [n [SEC[OND[S]]]]|NOWAIT] Alter Database ALTER DATABASE name [IF EXISTS] { SET ACCESS {READ ONLY | READ WRITE} | SET TOPOLOGY n PRIMAR{Y|IES} [m SECONDAR{Y|IES}] } Stop Database STOP DATABASE name [WAIT [n [SEC[OND[S]]]]|NOWAIT] Start Database START DATABASE name [WAIT [n [SEC[OND[S]]]]|NOWAIT] Drop Database DROP [COMPOSITE] DATABASE name [IF EXISTS] [{DUMP|DESTROY} [DATA]] [WAIT [n [SEC[OND[S]]]]|NOWAIT]","title":"Manipulation de bases de donn\u00e9es"},{"location":"cypher.html#exercice","text":"Soit la base de donn\u00e9es Northwind dont le sch\u00e9ma est le suivant : Cr\u00e9er un nouveau container Neo4j pour l'exercice Imorter les donn\u00e9es en ex\u00e9cutant le code suivant : // tag :: constraints [] CREATE CONSTRAINT FOR ( o : Order ) REQUIRE o . orderID IS UNIQUE ; // end :: constraints [] // tag :: indexes [] CREATE INDEX FOR ( m : Product ) ON ( m . productID ); CREATE INDEX FOR ( m : Product ) ON ( m . productName ); CREATE INDEX FOR ( m : Category ) ON ( m . categoryID ); CREATE INDEX FOR ( m : Employee ) ON ( m . employeeID ); CREATE INDEX FOR ( m : Supplier ) ON ( m . supplierID ); CREATE INDEX FOR ( m : Customer ) ON ( m . customerID ); CREATE INDEX FOR ( m : Customer ) ON ( m . customerName ); // end :: indexes [] // tag :: nodes [] // Create customers LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/customers.csv\" AS row CREATE (: Customer { companyName : row . CompanyName , customerID : row . CustomerID , fax : row . Fax , phone : row . Phone } ); // Create products LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/products.csv\" AS row CREATE (: Product { productName : row . ProductName , productID : row . ProductID , unitPrice : toFloat ( row . UnitPrice ) } ); // Create suppliers LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/suppliers.csv\" AS row CREATE (: Supplier { companyName : row . CompanyName , supplierID : row . SupplierID } ); // Create employees LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/employees.csv\" AS row CREATE (: Employee { employeeID : row . EmployeeID , firstName : row . FirstName , lastName : row . LastName , title : row . Title } ); // Create categories LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/categories.csv\" AS row CREATE (: Category { categoryID : row . CategoryID , categoryName : row . CategoryName , description : row . Description } ); LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/orders.csv\" AS row MERGE ( order : Order { orderID : row . OrderID } ) ON CREATE SET order . shipName = row . ShipName ; // end :: nodes [] // tag :: rels_orders [] LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/orders.csv\" AS row MATCH ( order : Order { orderID : row . OrderID } ) MATCH ( product : Product { productID : row . ProductID } ) MERGE ( order ) - [ pu : PRODUCT ] -> ( product ) ON CREATE SET pu . unitPrice = toFloat ( row . UnitPrice ), pu . quantity = toFloat ( row . Quantity ); LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/orders.csv\" AS row MATCH ( order : Order { orderID : row . OrderID } ) MATCH ( employee : Employee { employeeID : row . EmployeeID } ) MERGE ( employee ) - [: SOLD ] -> ( order ); LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/orders.csv\" AS row MATCH ( order : Order { orderID : row . OrderID } ) MATCH ( customer : Customer { customerID : row . CustomerID } ) MERGE ( customer ) - [: PURCHASED ] -> ( order ); // end :: rels_orders [] // tag :: rels_products [] LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/products.csv\" AS row MATCH ( product : Product { productID : row . ProductID } ) MATCH ( supplier : Supplier { supplierID : row . SupplierID } ) MERGE ( supplier ) - [: SUPPLIES ] -> ( product ); LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/products.csv\" AS row MATCH ( product : Product { productID : row . ProductID } ) MATCH ( category : Category { categoryID : row . CategoryID } ) MERGE ( product ) - [: PART_OF ] -> ( category ); // end :: rels_products [] // tag :: rels_employees [] LOAD CSV WITH HEADERS FROM \"https://github.com/neo4j-documentation/developer-resources/raw/gh-pages/data/northwind/employees.csv\" AS row MATCH ( employee : Employee { employeeID : row . EmployeeID } ) MATCH ( manager : Employee { employeeID : row . ReportsTo } ) MERGE ( employee ) - [: REPORTS_TO ] -> ( manager ); // end :: rels_employees [] R\u00e9pondre aux requ\u00eates suivantes : Trouver les produits et leurs prix. Trouver les informations sur les produits 'Chocolade' & 'Pavlova'. Trouver les informations sur les produits dont le nom commence par \"C\u201d et le prix >50. Requ\u00eate pr\u00e9c\u00e9dente en consid\u00e9rant \"sales price\" au lieu du prix du produit. Montant Total des achats par client et produit. Top 10 des employ\u00e9s selon les commandes vendues. Un employ\u00e9 est rattach\u00e9 \u00e0 combien de personnes de fa\u00e7on directe ou indirecte. \u00c0 qui les personnes nomm\u00e9es \u201cRobert\u201d sont-ils rattach\u00e9es. Qui n'a pas de personne \u00e0 qui il rattach\u00e9e ? Trouver les fournisseurs (Suppliers), le nombre de cat\u00e9gories qu'ils fournissent et la liste de ces cat\u00e9gories. Le client qui a achet\u00e9 le plus grand montant de la cat\u00e9gorie \"beverages\". Les 5 produits les plus populaires selon le nombre de commandes.","title":"Exercice"},{"location":"etl.html","text":"Importation de donn\u00e9es vers Neo4j \u00b6 \u00b6","title":"Importation de donn\u00e9es"},{"location":"etl.html#importation-de-donnees-vers-neo4j","text":"","title":"Importation de donn\u00e9es vers Neo4j"},{"location":"etl.html#_1","text":"","title":""},{"location":"installation.html","text":"Installation de Neo4j \u00b6 Formes de d\u00e9ploiement et versions \u00b6 Neo4j est disponible pour un d\u00e9ploiement on-premises ou comme un service sur le cloud sous le nom AuraDB . Pour une installation locale, il y a 2 versions : Neo4j Community Edition : version gratuite de base. Neo4j Enterprise Edition : n\u00e9cessite des licences pour des outils suppl\u00e9mentaires comme Bloom et Neo4j Ops Manager et offre des fonctionnalit\u00e9 de s\u00e9curit\u00e9 et de haute disponibilit\u00e9. Une comparaison est faite dans le tableau ci-apr\u00e8s : Pour chacune des 2 versions, il y a 3 formes de distributions : / Binaires pour Linux/Mac. Binaires pour Windows. Image Docker. L'offre cloud se d\u00e9cline en 3 formules : AuraDB Free (Gratuite) : pour apprentissage et prototypage avec des graphes ne d\u00e9passant pas 200K noeuds et 400K relations. Pour s'inscrire : https://console.neo4j.io AuraDB Professional : Jusqu'\u00e0 64GB/instance avec nombre d'instances illimit\u00e9 et service de sauvegarde. AuraDB Enterprise : Jusqu'\u00e0 384 GB/instance et une disponibilit\u00e9 de 99.95%, RBAC, ... Installation avec Docker \u00b6 Installation \u00b6 T\u00e9l\u00e9charger l'image officielle de Neo4j (ici la version 5.2.0) docker pull neo4j:5.2.0 Cr\u00e9er un container docker run -d --name neo4j -p 7474 :7474 -p 7687 :7687 -e NEO4J_AUTH = neo4j/test neo4j:5.2.0 V\u00e9rification \u00b6 Pour v\u00e9rifier que le container est en cours d'ex\u00e9cution : docker ps Se connecter \u00e0 Neo4j Browser sur http://localhost:7474 Entrer les param\u00e8tres de connexion login: neo4j et password: test. Ensuite, cliquer sur Connect . En cas de succ\u00e8s, Browser affiche : Cliquer sur l'icone Database pour afficher les informations de la connexion Entrer des requ\u00eates Pour saisir une requ\u00eate, placer le curseur devant l'invite neo4j$ Browser Browser est un outil inclus dans toutes les versions de Neo4j permettant de saisir de fa\u00e7on interactives les requ\u00eates en Cypher et interagier avec le SGBD ainsi que visualiser le r\u00e9sultat des requ\u00eates. D\u00e9marrer/Arr\u00eater Cassandra \u00b6 Maintenant, il est plus simple de d\u00e9marrer ou arr\u00eater Cassandra avec le container Docker d\u00e9j\u00e0 cr\u00e9\u00e9. Pour d\u00e9marrer : docker start neo4j Pour Arr\u00eater : docker stop neo4j Installation de Neo4j Desktop \u00b6 Neo4j Desktop est un IDE destin\u00e9 au d\u00e9veloppeur Neo4j. C'est aussi un environnement d'administration des instances Neo4j locales ou distantes. Neo4j Desktop inclut un licence Developer pour Neo4j Enterprise Edition permettant de manipuler et teser toutes les fonctionnalit\u00e9s et le outils compl\u00e9mentaires. Toutefois, il ne convient pas pour un environnement de production ni pour un fonctionnement en mode cluster. Il est possible d'installer et mettre \u00e0 jour des GraphApps ou plugins. T\u00e9l\u00e9charger Neo4j Desktop \u00e0 partir du centre de t\u00e9l\u00e9chargement de Neo4j Remplir le formulaire et commencer le t\u00e9l\u00e9chargeement. Enregistrer la licence D\u00e9marrer l'installation de Neo4j Desktop Selon la version de votre syst\u00e8me : : Fichier .exe :fontawesomw-brands-linux: : Fichier .AppImage (\u00e0 rendre ex\u00e9cutable avec chmod +x fichier.AppImage ) : Fichier .dmg Entrer le code de licence fourni dans l'\u00e9tape pr\u00e9c\u00e9dente puis Create local Graph . D\u00e9marrer la base de donn\u00e9es Lancer Neo4j Desktop et acc\u00e9der \u00e0 l'instance de base de donn\u00e9es avec Browser Cliquer sur la bouton Manage de la base de donn\u00e9es cr\u00e9\u00e9e et dans l'\u00e9cran suivant sur le bouton Open Browser","title":"Installation"},{"location":"installation.html#installation-de-neo4j","text":"","title":"Installation de Neo4j"},{"location":"installation.html#formes-de-deploiement-et-versions","text":"Neo4j est disponible pour un d\u00e9ploiement on-premises ou comme un service sur le cloud sous le nom AuraDB . Pour une installation locale, il y a 2 versions : Neo4j Community Edition : version gratuite de base. Neo4j Enterprise Edition : n\u00e9cessite des licences pour des outils suppl\u00e9mentaires comme Bloom et Neo4j Ops Manager et offre des fonctionnalit\u00e9 de s\u00e9curit\u00e9 et de haute disponibilit\u00e9. Une comparaison est faite dans le tableau ci-apr\u00e8s : Pour chacune des 2 versions, il y a 3 formes de distributions : / Binaires pour Linux/Mac. Binaires pour Windows. Image Docker. L'offre cloud se d\u00e9cline en 3 formules : AuraDB Free (Gratuite) : pour apprentissage et prototypage avec des graphes ne d\u00e9passant pas 200K noeuds et 400K relations. Pour s'inscrire : https://console.neo4j.io AuraDB Professional : Jusqu'\u00e0 64GB/instance avec nombre d'instances illimit\u00e9 et service de sauvegarde. AuraDB Enterprise : Jusqu'\u00e0 384 GB/instance et une disponibilit\u00e9 de 99.95%, RBAC, ...","title":"Formes de d\u00e9ploiement et versions"},{"location":"installation.html#installation-avec-docker","text":"","title":"Installation avec Docker"},{"location":"installation.html#installation","text":"T\u00e9l\u00e9charger l'image officielle de Neo4j (ici la version 5.2.0) docker pull neo4j:5.2.0 Cr\u00e9er un container docker run -d --name neo4j -p 7474 :7474 -p 7687 :7687 -e NEO4J_AUTH = neo4j/test neo4j:5.2.0","title":"Installation"},{"location":"installation.html#verification","text":"Pour v\u00e9rifier que le container est en cours d'ex\u00e9cution : docker ps Se connecter \u00e0 Neo4j Browser sur http://localhost:7474 Entrer les param\u00e8tres de connexion login: neo4j et password: test. Ensuite, cliquer sur Connect . En cas de succ\u00e8s, Browser affiche : Cliquer sur l'icone Database pour afficher les informations de la connexion Entrer des requ\u00eates Pour saisir une requ\u00eate, placer le curseur devant l'invite neo4j$ Browser Browser est un outil inclus dans toutes les versions de Neo4j permettant de saisir de fa\u00e7on interactives les requ\u00eates en Cypher et interagier avec le SGBD ainsi que visualiser le r\u00e9sultat des requ\u00eates.","title":"V\u00e9rification"},{"location":"installation.html#demarrerarreter-cassandra","text":"Maintenant, il est plus simple de d\u00e9marrer ou arr\u00eater Cassandra avec le container Docker d\u00e9j\u00e0 cr\u00e9\u00e9. Pour d\u00e9marrer : docker start neo4j Pour Arr\u00eater : docker stop neo4j","title":"D\u00e9marrer/Arr\u00eater Cassandra"},{"location":"installation.html#installation-de-neo4j-desktop","text":"Neo4j Desktop est un IDE destin\u00e9 au d\u00e9veloppeur Neo4j. C'est aussi un environnement d'administration des instances Neo4j locales ou distantes. Neo4j Desktop inclut un licence Developer pour Neo4j Enterprise Edition permettant de manipuler et teser toutes les fonctionnalit\u00e9s et le outils compl\u00e9mentaires. Toutefois, il ne convient pas pour un environnement de production ni pour un fonctionnement en mode cluster. Il est possible d'installer et mettre \u00e0 jour des GraphApps ou plugins. T\u00e9l\u00e9charger Neo4j Desktop \u00e0 partir du centre de t\u00e9l\u00e9chargement de Neo4j Remplir le formulaire et commencer le t\u00e9l\u00e9chargeement. Enregistrer la licence D\u00e9marrer l'installation de Neo4j Desktop Selon la version de votre syst\u00e8me : : Fichier .exe :fontawesomw-brands-linux: : Fichier .AppImage (\u00e0 rendre ex\u00e9cutable avec chmod +x fichier.AppImage ) : Fichier .dmg Entrer le code de licence fourni dans l'\u00e9tape pr\u00e9c\u00e9dente puis Create local Graph . D\u00e9marrer la base de donn\u00e9es Lancer Neo4j Desktop et acc\u00e9der \u00e0 l'instance de base de donn\u00e9es avec Browser Cliquer sur la bouton Manage de la base de donn\u00e9es cr\u00e9\u00e9e et dans l'\u00e9cran suivant sur le bouton Open Browser","title":"Installation de Neo4j Desktop"},{"location":"python.html","text":"Pilote Python pour neo4j \u00b6 \u00b6","title":"Pilote Python"},{"location":"python.html#pilote-python-pour-neo4j","text":"","title":"Pilote Python pour neo4j"},{"location":"python.html#_1","text":"","title":""}]}